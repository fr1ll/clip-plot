# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_utils.ipynb.

# %% auto 0
__all__ = ['FILE_NAME', 'get_version', 'round_floats', 'is_number', 'date_to_seconds', 'round_date', 'timestamp',
           'datestring_to_date', 'get_path', 'write_json', 'read_json', 'copytree_agnostic', 'clean_filename']

# %% ../nbs/01_utils.ipynb 2
import os
import sys
import json
from typing import Any
import datetime
from shutil import copytree
from urllib.parse import unquote
from dateutil.parser import parse as parse_date

from pathlib import Path

# %% ../nbs/01_utils.ipynb 3
FILE_NAME = "filename"  # Filename name key

# %% ../nbs/01_utils.ipynb 4
def get_version():
    """
    Return the version of clipplot installed
    Hardcoded for now
    """
    # return pkg_resources.get_distribution("clipplot").version
    return "0.0.1"

# %% ../nbs/01_utils.ipynb 6
def round_floats(obj, digits=5):
    """Return 2D array obj with rounded float precision"""
    return [[round(float(j), digits) for j in i] for i in obj]

# %% ../nbs/01_utils.ipynb 7
def is_number(s: str) -> bool:
    try:
        int(s)
        return True
    except ValueError:
        return False

# %% ../nbs/01_utils.ipynb 9
def date_to_seconds(date):
    """
    Given a datetime object return an integer representation for that datetime
    """
    if isinstance(date, datetime.datetime):
        return (date - datetime.datetime.today()).total_seconds()
    else:
        return -float("inf")


def round_date(date, unit):
    """
    Return `date` truncated to the temporal unit specified in `units`
    """
    if not isinstance(date, datetime.datetime):
        return "no_date"
    formatted = date.strftime("%d %B %Y -- %X")
    if unit in {"seconds", "minutes", "hours"}:
        date = formatted.split("--")[1].strip()
        if unit == "seconds":
            date = date
        elif unit == "minutes":
            date = ":".join(d.split(":")[:-1]) + ":00"
        elif unit == "hours":
            date = date.split(":")[0] + ":00:00"
    elif unit in {"days", "months", "years", "decades", "centuries"}:
        date = formatted.split("--")[0].strip()
        if unit == "days":
            date = date
        elif unit == "months":
            date = " ".join(date.split()[1:])
        elif unit == "years":
            date = date.split()[-1]
        elif unit == "decades":
            date = str(int(date.split()[-1]) // 10) + "0"
        elif unit == "centuries":
            date = str(int(date.split()[-1]) // 100) + "00"
    return date

# %% ../nbs/01_utils.ipynb 10
def timestamp():
    """Return a string for printing the current time"""
    return str(datetime.datetime.now()) + ":"

# %% ../nbs/01_utils.ipynb 11
def datestring_to_date(datestring):
    """
    Given a string representing a date return a datetime object
    """
    try:
        return parse_date(
            str(datestring), fuzzy=True, default=datetime.datetime(9999, 1, 1)
        )
    except Exception as exc:
        print(timestamp(), "Could not parse datestring {}".format(datestring))
        return datestring

# %% ../nbs/01_utils.ipynb 13
def get_path(subdir: str, filename: str, *, out_dir: str):
    """Return the path to a JSON file with conditional hash
    """
    out = Path(out_dir)
    if subdir:
        out = out / subdir
    return (out/ filename).with_suffix(".json").as_posix()

# %% ../nbs/01_utils.ipynb 14
def write_json(output_path: Path, object: Any):
    """
    Write json object `obj` to disk and return the path to that file
    """
    output_path.parent.mkdir(parents=True, exist_ok=True)
    with output_path.open("w", encoding="utf-8") as out:
        json.dump(object, out, indent=4)

# %% ../nbs/01_utils.ipynb 15
def read_json(path: Path) -> dict:
    with path.open("r") as f:
        return json.load(f)

# %% ../nbs/01_utils.ipynb 17
def copytree_agnostic(a,b):
    if sys.version_info.major >=3 and sys.version_info.minor >=8:
        copytree(a, b, dirs_exist_ok=True)
    else:
        from distutils.dir_util import copy_tree
        copy_tree(a, b)

# %% ../nbs/01_utils.ipynb 20
def clean_filename(s: str) -> str:
    """Given a string that points to a filename, return a clean filename
    """
    s = unquote(os.path.basename(s))
    invalid_chars = '<>:;,"/\\|?*[]'
    for i in invalid_chars:
        s = s.replace(i, "")
    return s
