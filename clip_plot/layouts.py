# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/05_layouts.ipynb.

# %% auto 0
__all__ = ['write_layout', 'BaseLayout', 'BaseMetaLayout', 'AlphabeticLayout', 'Box', 'get_categorical_boxes',
           'get_categorical_points', 'CategoricalLayout', 'CustomLayout', 'get_pointgrid_layout',
           'get_rasterfairy_layout', 'get_umap_layout_or_layouts', 'get_single_umap_model', 'get_heightmap',
           'get_layouts']

# %% ../nbs/05_layouts.ipynb 2
from .utils import timestamp, get_json_path, write_json, read_json, round_floats
from .configuration import UmapSpec
from .images import ImageFactory

from abc import ABC, abstractmethod
from typing import Any
import math
import itertools
from collections import defaultdict
from pathlib import Path
import operator
from dataclasses import dataclass

# TODO: Change math references to numpy

import numpy as np
from scipy.stats import gaussian_kde
import matplotlib.pyplot as plt
from umap import UMAP, AlignedUMAP
from sklearn.preprocessing import minmax_scale
import rasterfairy
from rasterfairy import coonswarp
from pointgrid import align_points_to_grid

# %% ../nbs/05_layouts.ipynb 7
def write_layout(path: Path, obj: Any, scale: bool = True, round: bool = True):
    """
    Write layout json `obj` to disk and return the path to the saved file
    """
    if scale:
        # scale -1:1
        obj = (minmax_scale(obj) - 0.5) * 2
    if round:
        obj = round_floats(obj)
    if isinstance(obj, np.ndarray):
        obj = obj.tolist()
    return write_json(path, obj)


# %% ../nbs/05_layouts.ipynb 8
class BaseLayout(ABC):
    # Hardcoded for each particular layout
    # User should change
    _SCALE = True
    _ROUND = True
    _SUBDIR = "layouts"
    _FILENAME = ""
    _ADD_HASH = True

    def __init__(self, plot_id: str, data_dir: Path):
        self.plot_id = plot_id
        self.data_dir = data_dir

    @abstractmethod
    def get_layout(self):
        # Get or create layout
        pass


class BaseMetaLayout(BaseLayout):
    def __init__(self, plot_id, imageEngine) -> None:
        super().__init__(plot_id, imageEngine.data_dir)
        self.imageEngine = imageEngine

class AlphabeticLayout(BaseMetaLayout):
    _SUBDIR = "layouts"
    _FILENAME = "grid"

    def get_layout(self):
        """
        Get the x,y positions of images in a grid projection
        """
        print(timestamp(), "Creating grid layout")
        out_path = get_json_path(self.data_dir, self._SUBDIR, self._FILENAME, self.plot_id)
        n = math.ceil(self.imageEngine.count ** (1 / 2))
        l = []  # positions
        for i in range(self.imageEngine.count):
            x = i % n
            y = math.floor(i / n)
            l.append([x, y])
        z = np.array(l)

        write_layout(out_path, z)
        return out_path

# %% ../nbs/05_layouts.ipynb 9
@dataclass
class Box:
        n_cells: int
        width: int
        height: int
        x: int | None
        y: int | None

def get_categorical_boxes(group_counts: list[int], margin=2):
    """
    @arg [int] group_counts: counts of the number of images in each
      distinct level within the metadata's categories
    @kwarg int margin: space between boxes in the 2D layout
    @returns [Box] an array of Box() objects; one per level in `group_counts`
    """
    group_counts = sorted(group_counts, reverse=True)
    boxes = []
    for i in group_counts:
        w = h = math.ceil(i ** (1 / 2))
        boxes.append(Box(i, w, h, None, None))
    # find the position along x axis where we want to create a break
    wrap = math.floor(sum([b.n_cells for b in boxes]) ** (1 / 2)) - (2 * margin)
    # find the valid positions on the y axis
    y = margin
    y_spots = []
    for box in boxes:
        if (y + box.height + margin) <= wrap:
            y_spots.append(y)
            y += box.height + margin
        else:
            y_spots.append(y)
            break
    # get a list of lists where sublists contain elements at the same y position
    y_spot_index = 0
    for box in boxes:
        # find the y position
        y = y_spots[y_spot_index]
        # find members with this y position
        row_members = [b.x + b.width for b in boxes if b.y == y]
        # assign the y position
        box.y = y
        y_spot_index = (y_spot_index + 1) % len(y_spots)
        # assign the x position
        box.x = max(row_members) + margin if row_members else margin
    return boxes

def get_categorical_points(boxes: np.ndarray, unit_size=None):
    """Given an array of Box() objects, return a 2D distribution with shape (n_cells, 2)"""
    points_arr = []
    for box in boxes:
        area = box.width * box.height
        per_unit = (area / box.n_cells) ** (1 / 2)
        x_units = math.ceil(box.width / per_unit)
        y_units = math.ceil(box.height / per_unit)
        if not unit_size:
            unit_size = min(box.width / x_units, box.height / y_units)
        for j in range(box.n_cells):
            x = j % x_units
            y = j // x_units
            points_arr.append(
                [
                    box.x + x * unit_size,
                    box.y + y * unit_size,
                ]
            )
    return np.array(points_arr)

# %% ../nbs/05_layouts.ipynb 10
class CategoricalLayout(BaseMetaLayout):
    _NULL_CATEGORY = "Other"
    _MARGIN = 2
    _FILENAME = "categorical"

    def get_layout(self):
        """
        Return a numpy array with shape (n_points, 2) with the point
        positions of observations in box regions determined by
        each point's category metadata attribute (if applicable)

        Args:
            null_category (Optional[str]='Other')
            margin (Optional[int]=2)
            metadata
        """
        if "category" not in self.imageEngine.meta_headers:
            return False

        print(timestamp(), "Creating categorical layout")
        # determine the out path and return from cache if possible
        layout_out_path = get_json_path(self.data_dir, self._SUBDIR, self._FILENAME, self.plot_id)
        labels_out_path = get_json_path(self.data_dir, self._SUBDIR, "categorical-labels", self.plot_id)

        # accumulate d[category] = [indices of points with category]
        categories = [img.metadata.get("category", None) for img in self.imageEngine]
        if not any(categories) or len(set(categories) - {None}) == 1:
            return False
        d = defaultdict(list)
        for idx, i in enumerate(categories):
            d[i].append(idx)

        # store the number of observations in each group
        keys_and_counts = [{"key": i, "count": len(d[i])} for i in d]
        keys_and_counts.sort(key=operator.itemgetter("count"), reverse=True)
        # get the box layout then subdivide into discrete points
        boxes = get_categorical_boxes([i["count"] for i in keys_and_counts], margin=self._MARGIN)
        points = get_categorical_points(boxes)
        # sort the points into the order of the observations in the metadata
        counts = {i["key"]: 0 for i in keys_and_counts}
        offsets = {i["key"]: 0 for i in keys_and_counts}
        for idx, i in enumerate(keys_and_counts):
            offsets[i["key"]] += sum([j["count"] for j in keys_and_counts[:idx]])
        sorted_points = []
        for img in self.imageEngine:
            category = img.metadata.get("category", self._NULL_CATEGORY)
            sorted_points.append(points[offsets[category] + counts[category]])
            counts[category] += 1
        sorted_points = np.array(sorted_points)
        # add to the sorted points the anchors for the text labels for each group
        text_anchors = np.array([[i.x, i.y - self._MARGIN / 2] for i in boxes])
        # add the anchors to the points - these will be removed after the points are projected
        sorted_points = np.vstack([sorted_points, text_anchors])
        # scale -1:1 using the largest axis as the scaling metric
        _max = np.max(sorted_points)
        for i in range(2):
            _min = np.min(sorted_points[:, i])
            sorted_points[:, i] -= _min
            sorted_points[:, i] /= _max - _min
            sorted_points[:, i] -= np.max(sorted_points[:, i]) / 2
            sorted_points[:, i] *= 2
        # separate out the sorted points and text positions
        text_anchors = sorted_points[-len(text_anchors) :]
        sorted_points = sorted_points[: -len(text_anchors)]
        z = round_floats(sorted_points.tolist())
        write_json(layout_out_path, z)
        write_json(labels_out_path,
            {"positions": round_floats(text_anchors.tolist()),
            "labels": [i["key"] for i in keys_and_counts],},
            )
        return {"layout": layout_out_path,
                "labels": labels_out_path}

# %% ../nbs/05_layouts.ipynb 11
class CustomLayout(BaseMetaLayout):
    _FILENAME = "custom"

    def get_layout(self):
        """
        Return a 2D array of image positions corresponding to x,y coordinates in metadata
        """
        out_path = get_json_path(self.data_dir, self._SUBDIR, self._FILENAME, self.plot_id)
        if not self.imageEngine.metadata:
            return
        found_coords = False
        coords = []
        for i in self.imageEngine:
            x = i.metadata.get("x")
            y = i.metadata.get("y")
            if x and y:
                found_coords = True
                coords.append([x, y])
            else:
                if found_coords:
                    print(
                        timestamp(),
                        "Some images are missing coordinates; skipping custom layout",
                    )
                    return

        if not found_coords:
            return
        else:
            print(timestamp(), "Creating custom layout based on xy coordinates in metadata")
        coords = np.array(coords).astype(float)
        coords = (minmax_scale(coords) - 0.5) * 2
        print(timestamp(), "Creating custom layout")
        write_layout(out_path, coords.tolist())
        return {"layout": out_path}

# %% ../nbs/05_layouts.ipynb 12
def get_pointgrid_layout(input_path: Path, data_dir: Path, label, plot_id: str):
    """Gridify the positions in `path` and return the path to this new layout
    Args:
        path (str)
        label (str)
    """
    print(timestamp(), "Creating {label} pointgrid")
    out_path = get_json_path(data_dir=data_dir, subdir="layouts",
                             filename=f"{label}-jittered",
                             plot_id=plot_id)

    arr = np.array(read_json(input_path))
    if arr.shape[-1] != 2:
        print(timestamp(), "Could not create pointgrid layout because data is not 2D")
        return None

    z = align_points_to_grid(arr, fill=0.05)
    return write_layout(out_path, z)


# %% ../nbs/05_layouts.ipynb 13
def get_rasterfairy_layout(data_dir: Path, plot_id: str, umap_json_path: Path):
    """Create regular grid layout that keeps umap XYs close to each other
    """
    print(timestamp(), "Creating rasterfairy layout")
    out_path = get_json_path(data_dir, "layouts", "rasterfairy", plot_id)
    umap = np.array(read_json(umap_json_path))
    if umap.shape[-1] != 2:
        print(timestamp(), f"Couldn't create rasterfairy layout. Data shape is {umap.shape}, needs to be 2D.")
        return None
    umap = (umap + 1) / 2  # scale 0:1
    try:
        umap = coonswarp.rectifyCloud(
            umap,  # stretch the distribution
            perimeterSubdivisionSteps=4,
            autoPerimeterOffset=False,
            paddingScale=1.05,
        )
    except Exception as exc:
        print(timestamp(), "Coonswarp rectification could not be performed", exc)
    pos = rasterfairy.transformPointCloud2D(umap)[0]
    return write_layout(out_path, pos)

# %% ../nbs/05_layouts.ipynb 14
def get_umap_layout_or_layouts(v: np.ndarray, imageEngine, umap_spec: UmapSpec,
                              data_dir: Path, plot_id: str) -> dict[str, list]:
    """Create a multi-layout UMAP projection
    Args:
        v (array like object)
        n_neighbors
        min_dist
        images
    """
    print(timestamp(), "Creating multi-umap layout")
    umap_variants = []
    for n_neighbors, min_dist in itertools.product(
        umap_spec.n_neighbors, umap_spec.min_dist
    ):
        filename = f"umap-n_neighbors_{n_neighbors}-min_dist_{min_dist}"
        out_path = get_json_path(data_dir, "layouts", filename, plot_id)
        umap_variants.append(
            {
                "n_neighbors": n_neighbors,
                "min_dist": min_dist,
                "filename": filename,
                "out_path": out_path,
            }
        )

    singleLayout = len(umap_variants) == 1

    # map each image's index to itself and create one copy of that map for each layout
    relations_dict = {idx: idx for idx, _ in enumerate(v)}

    # determine the subset of umap_variants that have already been computed
    uncomputed_variants = [v for v in umap_variants if not v["out_path"].exists()]

    # Use labels for fitting if available
    y = []
    if "label" in imageEngine.meta_headers:
        labels = [img.metadata.get("label", None) for img in imageEngine]
        # if the user provided labels, integerize them
        if any(label for label in labels):
            d = defaultdict(lambda: len(d))
            for label in labels:
                if label is None:
                    y.append(-1)
                else:
                    y.append(d[label])
            """
            Currently there is no way to have a particular image with the missing field for 
            "label". For scenarios with metadata, If an image is not matched, it is excluded from
            the project.  If the meta value is empty, it will still have "" value .
            """
            y = np.array(y)

        # Fit the model on the data
        if singleLayout: # Single layout
            model = get_single_umap_model(umap_spec)
            z = model.fit(v, y=y if np.any(y) else None).embedding_
            write_layout(umap_variants[0]["out_path"], z)

        else:  # Multiple layouts
            model = AlignedUMAP(
                n_neighbors=[v["n_neighbors"] for v in uncomputed_variants], # type: ignore
                min_dist=[v["min_dist"] for v in uncomputed_variants], # type: ignore
            )
            z = model.fit(
                [v for _ in umap_variants], y=[y if np.any(y) else None for _ in umap_variants], relations=[relations_dict for _ in umap_variants[1:]]
            )
            for i, v in enumerate(umap_variants):
                write_layout(v["out_path"], z.embeddings_[i]) # type: ignore

    # return layout variants
    return {"variants": [
                    {
                        "n_neighbors": v["n_neighbors"],
                        "min_dist": v["min_dist"],
                        "layout": v["out_path"],
                        "jittered": get_pointgrid_layout(
                            input_path=v["out_path"], data_dir=data_dir,
                            label=v["filename"], # what does label do?
                            plot_id=plot_id
                        ),
                        # "grid": get_rasterfairy_layout(
                        #     umap_json_path=v["out_path"], data_dir=data_dir,
                        #     plot_id=plot_id
                        # )
                    }
                for v in umap_variants
                ]
    }


def get_single_umap_model(umap_spec: UmapSpec, seed: int | None = None) -> UMAP:
    """
    unpack params list and handle UMAP not letting transform_seed be None
    """
    config ={
        "n_neighbors" : umap_spec.n_neighbors[0],
        "min_dist" : umap_spec.min_dist[0],
        "n_components" : 2,
        "metric" : umap_spec.metric,
        "random_state" : seed,
    }
    if seed:
        config.update({"transform_seed": seed})
    return UMAP(**config)

# %% ../nbs/05_layouts.ipynb 15
def get_heightmap(json_path: Path, label: str, data_dir: Path):
    """Create a heightmap using the distribution of points stored at `path`
    Args:
        path
        label
        data_dir
    """

    X = read_json(json_path)
    if "positions" in X:
        X = X["positions"]
    X = np.array(X)
    if X.shape[-1] != 2:
        print(timestamp(), "Could not create heightmap because data is not 2D")
        return
    # create kernel density estimate of distribution X
    nbins = 200
    x, y = X.T
    xi, yi = np.mgrid[x.min() : x.max() : nbins * 1j, y.min() : y.max() : nbins * 1j]
    kernel = gaussian_kde(X.T)
    zi = kernel(np.vstack([xi.flatten(), yi.flatten()]))
    # create the plot
    fig, _ = plt.subplots(nrows=1, ncols=1, figsize=(5, 5))
    fig.subplots_adjust(0, 0, 1, 1)
    plt.pcolormesh(xi, yi, zi.reshape(xi.shape), shading="gouraud", cmap=plt.cm.gray)
    plt.axis("off")
    # save the plot
    hmap_dir = data_dir/ "heightmaps"
    hmap_dir.mkdir(parents=True, exist_ok=True)
    out_path = hmap_dir / f"{label}-heightmap.png"
    plt.savefig(out_path, pad_inches=0)

# %% ../nbs/05_layouts.ipynb 16
def get_layouts(imageEngine: ImageFactory, hidden_vectors: np.ndarray,
                data_dir: Path, plot_id: str,
                umap_spec: UmapSpec,
                ):
    """Get the image positions in each projection"""

    alphabetic_layout = AlphabeticLayout(plot_id, imageEngine)
    categorical_layout = CategoricalLayout(plot_id, imageEngine)
    custom_layout = CustomLayout(plot_id, imageEngine)
    umap_layouts_dict = get_umap_layout_or_layouts(hidden_vectors, imageEngine, umap_spec,
                                                data_dir, plot_id)
    layouts = {
        "umap": umap_layouts_dict,
        "alphabetic": {
            "layout": alphabetic_layout.get_layout(),
        },
        "grid": {
            "layout": get_rasterfairy_layout(
                              umap_json_path=umap_layouts_dict["variants"][0]["layout"],
                              data_dir=data_dir, plot_id=plot_id
                              ),
        },
        "categorical": categorical_layout.get_layout(),
        "custom": custom_layout.get_layout(),
    }
    return layouts
